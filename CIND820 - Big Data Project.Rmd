---
title: "Predicting the Rating of Google Play Store Application Using K-Nearest Neighbour and Naive Bayes Approach"
output:
  word_document: default
  html_notebook: default
---
Abstract
  As technology continues to improve and an increasing amount of people continues to rely on their phones, the mobile market has grown extensively. As a result, there are a lot of reasons for developing applications(“apps”), such as increasing market coverage and improving customer experience for businesses or simply to earn money through mobile games. 
  There is a substantial amount of money being generated by mobile apps, however, not all types of apps generate money, and most do not. Using classification algorithms, I’m interested in determining which characteristics is associated with popular and/or top grossing mobile applications in the Google Play Store. The result of this research could be used as a marketing strategy to successfully develop an application incorporating those characteristics to be launched in the future.  
  In this project, the objective of this research is to use the Google Play Store Apps dataset obtained from https://www.kaggle.com/lava18/google-play-store-apps to predict the ratings of Google Play Store applications given the other attributes.  The dataset contains the following 13 attributes: App, Category, Rating, Reviews, Size, Installs, Type, Price, Content Rating, Genre, Last Updated, Current Version, and Android Version. Since ratings of the app is the dependent categorical variable containing five levels, I will be using Naïve Bayes and KNN algorithms using R Studio and Weka. Lastly, I also want to determine which apps are top-rated in each category, and which attributes are associated with higher installation. 

Introduction

Literature Review
Ratings determine the point of sales and downloads. 
	One of the driving forces for app sales and downloads is determined by the app’s ratings. It is shown that rating is one of the key determinants of smartphone app purchase (Kim et al., 2011). Their research has shown that smartphone users are more likely to purchase apps that have high ranking in the mobile market. In a study using Google Play dataset, Hyrynsalmi et al. (2015) found that the higher value of valence of users rating is an indicator of both short- and long-term sales. Additionally, a similar research found that there is a correlation between the apps download in almost every category and customer rating (Harman et al., 2012).  Therefore, it will be interesting to see if there is relationship between installation and rating in my dataset. 

Star ratings is inaccurate in determining users’ level of satisfaction. 
  Despite the wide use of the star-rating system, there are still a lot of challenges to this approach. Several researches have determined that the use of star ratings is insufficient in reflecting the current level of satisfaction for users. Mojica Ruiz et al. (2015) found that the ratings of the apps is inflexible to the change in the score when it has accumulated a significant amount of ratings. For example, if a minority of the current app users are having trouble with the app and have decided to give the app a rating of two, this small amount of new ratings is not significant enough to change the current rating. This in turn poses a problem because it does not allow the developers to resolve the issues nor improve the quality of the app as quickly as possible.  Furthermore, researches conducted Aralikatte et al. (2018) and Umer et. al (2020) found that the star ratings do not always match the reviews posted by the users. Aralikatte et al. (2018) shows that it is possible for a highly negative review to have a five-rating rating and could occur for several reasons such as, a user may initially have a positive experience giving the rating of five stars but could later have negative experience leading him to write a negative review and may forget to update his rating. Lastly there is a difficulty involved in using the rating system due to bias (Malik et al., 2020). Since the star rating represents the average of the rating for the app, the combination of both positive and negative ratings makes it difficult for the app developers to discern between the level of the ratings. 

Related Work. 
  Various researchers have developed tools and approach on accurately predicting the ratings of applications. An investigation by Sarro et al. (2018) states that mining the ratings and the features associated with the existing app can be used in order to predict the likely customer rating to a new proposed app based with the features it is associated with. The extracted raw data from the app store is analyzed to retrieve all the attributes associated with the app in order to identify its technical features. They then used Cased Based Reasoning to acquire the k most similar apps in the database to predict the rating. Another approach by Umer et al. (2020) involved predicting the numeric ratings of apps using user reviews. The features generated by the term frequency/inverse document frequency were passed on to machine learning algorithms such as, the random forest, the gradient boosting classifier, the extreme gradient boosting classifier, the AdaBoost classifier, and the extra tree classifier. 

Dataset and Description
  The original dataset comes from https://www.kaggle.com/lava18/google-play-store-apps and it is about applications in the Google Play Store and the attributes associated with applications. The goal of this classification is to predict the rating (High/Medium/ Low) of the applications from the Google Play Store. 

  The original dataset has 10841 entries and 13 columns.  However, after cleaning and processing, the new dataset contains 9360 entries and 10 columns.

Github Repository:

Input variables
1.	Application name(categorical).
2.	Category: category of application (categorical: "ART_AND_DESIGN",  "AUTO AND VEHICLES", "BEAUTY", "BOOKS AND REFERENCE", "BUSINESS"            "COMICS", "COMMUNICATION", "DATING", "EDUCATION", "ENTERTAINMENT"       "EVENTS", "FAMILY", "FINANCE", "FOOD AND DRINK", "GAME",    "HEALTH AND FITNESS", "HOUSE AND HOME", "LIBRARIES AND DEMO", "LIFESTYLE",      "MAPS AND NAVIGATION", "MEDICAL", "NEWS AND MAGAZINES", "PARENTING",        "PERSONALIZATION", "PHOTOGRAPHY", "PRODUCTIVITY", "SHOPPING", "SOCIAL",         "SPORTS", "TOOLS", "TRAVEL AND LOCAL", "VIDEO PLAYERS", "WEATHER")
3.	Rating: rating status (categorical: “High”, “Medium”, “Low”)
4.	Reviews: the size/amount of reviews written for each application (numeric).
5.	Size: the size of the app, in byte (numeric).
6.	Installs: the number of installations (numeric)
7.	Type: whether the app is free or paid (categorical: “Free” = 1, “Paid” = 0) 
8.	Price: cost of each application (numeric). 
9.	Content Rating: the age group the app is targeted to (categorical: “Adults only 18+” = 1, “Everyone” = 2, “Everyone 10+” = 3, “Mature 17+ = 4, “Teen” = 5, “Others” = 6)
10.	Genres: genre of each application (categorical: "Action", "Adventure", "Arcade", "Art & Design",  "Auto & Vehicles", "Beauty", "Board", "Books & Reference", "Business", "Card", "Casino",       "Casual", "Comics", "Communication", "Dating", "Education”, "Educational", "Entertainment", "Events", "Finance", "Food & Drink", "Health & Fitness", "House & Home", "Libraries & Demo", "Lifestyle", "Maps & Navigation", "Medical", "Music", "Music & Audio", "News & Magazines", "Parenting", "Personalization", "Photography", "Productivity", "Puzzle", "Racing", "Role Playing", "Shopping", "Simulation", "Social", "Sports", "Strategy", "Tools", "Travel & Local", "Trivia",  "Video Players & Editors",  "Weather", "Word")

Exploratory Analysis
```{r}
library(dplyr)
library(MASS)
library(ggplot2)
library(class)
library(gmodels)
library(naivebayes)
```

Loading Google Play Store Apps dataset
```{r}
googleApps = read.csv("/Users/user/Documents/CIND820 - Big Data Analytics Project/googleAppsNew4.csv",header =  T, sep = ",")
str(googleApps)
```


```{r}
###Turn Rating into factor with three levels
googleApps$Rating <- factor(googleApps$Rating, order = TRUE, levels = c('High','Medium','Low'))
googleApps$Category <- as.factor(googleApps$Category)
googleApps$Genres <- as.factor(googleApps$Genres)
```
Turning Rating, Category, and Genres into factor.


```{r}
googleApps$Size[is.na(googleApps$Size)] <- median(googleApps$Size, na.rm = TRUE)
```
Replace NAs with median


Univariate Analysis
```{r}
aggregate(googleApps$Reviews,by = list(Rating = googleApps$Rating), FUN=mean)
aggregate(googleApps$Reviews,by = list(Rating = googleApps$Rating), FUN=median)
```


```{r}
aggregate(googleApps$Size,by = list(Rating = googleApps$Rating), FUN=mean, na.rm = T)
aggregate(googleApps$Size,by = list(Rating = googleApps$Rating), FUN=median, na.rm = T)
```

```{r}
aggregate(googleApps$Installs,by = list(Rating = googleApps$Rating), FUN=mean)
aggregate(googleApps$Installs,by = list(Rating = googleApps$Rating), FUN=median)
```

```{r}
aggregate(googleApps$Price,by = list(Rating = googleApps$Rating), FUN=mean)
aggregate(googleApps$Price,by = list(Rating = googleApps$Rating), FUN=median)
```



```{r}
count_Category <- table(googleApps$Category)
count_Category
count_Rating <- table(googleApps$Rating)
count_Rating
count_Type <- table(googleApps$Type)
count_Type
count_CR <- table(googleApps$Content.Rating)
count_CR
count_Genre <- table(googleApps$Genre)
count_Genre
```



```{r}
rating.freq = table(count_Rating)
rating.freq
rating.relfreq = rating.freq / nrow(googleApps)
rating.relfreq
```


```{r}
barplot(count_Rating,main="Rating Distribution", xlab="Rating")
```


```{r}

```




```{r}
ggplot(googleApps, aes (x = Category)) + geom_bar() + theme(axis.text.x = element_text(angle = 60, hjust = 1))
```

```{r}
hist(googleApps$Reviews, xlab = "Reviews", main = "Histogram of Reviews")
```


```{r}
hist(googleApps$Size, xlab = "Size", main = "Histogram of Size")
```

```{r}
hist(googleApps$Installs, xlab = "Installs", main = "Histogram of Installs")
```

```{r}
barplot(count_Type,main="Type Distribution", xlab="Type")
```

```{r}
hist(googleApps$Price, xlab = "Price", main = "Histogram of Price")
```

```{r}
barplot(count_CR,main="Content Rating Distribution", xlab="Content Rating")
```

```{r}
ggplot(googleApps, aes (x = Genres)) + geom_bar() + theme(axis.text.x = element_text(angle = 60, hjust = 1))
```

```{r}
## Summary Statistics (Mean, Median, Std)
summary(googleApps) 
```

Bivariate Analysis - Relationship between Rating and Independent Variables 
```{r}
ggplot(googleApps, aes(x = Category, fill = Rating)) + geom_bar(position = "dodge") + theme(axis.text.x = element_text(angle = 60, hjust = 1))
```


```{r}
boxplot(googleApps$Reviews ~ googleApps$Rating, col="orange", main="Distribution of Reviews",ylab="Reviews", xlab="Rating") 
```

```{r}
boxplot(googleApps$Size ~ googleApps$Rating, col="orange", main="Distribution of Size",ylab="Size", xlab="Rating") 
```


```{r}
ggplot(googleApps, aes(x = Type, fill = Rating)) + geom_bar(position = "dodge") + theme(axis.text.x = element_text(angle = 60, hjust = 1))
```


```{r}
boxplot(googleApps$Installs ~ googleApps$Rating, col="orange", main="Distribution of Installs",ylab="Installs", xlab="Rating") 
```


```{r}
boxplot(googleApps$Price ~ googleApps$Rating, col="orange", main="Distribution of Price",ylab="Price", xlab="Rating") 
```


```{r}
ggplot(googleApps, aes(x = googleApps$Content.Rating, fill = Rating)) + geom_bar(position = "dodge") 
```


```{r}
ggplot(googleApps, aes(x = Genres, fill = Rating)) + geom_bar(position = "dodge") + theme(axis.text.x = element_text(angle = 60, hjust = 1))
```


```{r}
##Remove Application Name
googleApps <- googleApps[-1]
googleApps <- googleApps[-9] 
```


Prediction Results
```{r}
table(googleApps$Rating)   

googleApps$rating <- factor(googleApps$Rating,
                        levels = c("High", "Medium", "Low"),
                        labels = c("H", "M","L"))

round(prop.table(table(googleApps$rating)) * 100, digits = 1)
```
The proportions for Rating is uneven. We can see that majority of the rating is High, compared to Medium and Low.

```{r}
##Feature Scaling
normalize <- function(x) {
  return ((x - min(x)) / (max(x) - min(x))) }

googleApps_new <- as.data.frame(lapply(googleApps[3:8], normalize))    
googleApps_new <- cbind(googleApps$rating,googleApps_new)
```

```{r}
##Split the dataset into training and test set
set.seed(123)
index <- sample(1:nrow(googleApps_new), 0.65 *nrow(googleApps_new))
googleApps_train <- googleApps_new[index,]
googleApps_test <- googleApps_new[-index,]
```

Using K-Nearest Neighbour Approach
```{r}
googleApps_train_labels <- googleApps_train[,1]
googleApps_test_labels <- googleApps_test[,1]

googleApps_test_pred10 <- knn(train = googleApps_train[,2:7],
                     test = googleApps_test[,2:7],
                     cl = googleApps_train_labels, k=10)
```
Using k=10 

```{r}
googleApps_test_pred50 <- knn(train = googleApps_train[,2:7],
                            test = googleApps_test[,2:7],
                            cl = googleApps_train_labels, k=50)
```
Using k = 50

```{r}
googleApps_test_pred96 <- knn(train = googleApps_train[,2:7],
                            test = googleApps_test[,2:7],
                            cl = googleApps_train_labels, k=96)
```
Using k = 50. Since the square root of the number of entries is 96, k = 96 seems to be the best k value. 

```{r}
###Confusion Matrix
table(Actual=googleApps_test_labels, Predicted=googleApps_test_pred10)
CrossTable(x = googleApps_test_labels, y = googleApps_test_pred10, prop.chisq = F)

table(Actual=googleApps_test_labels, Predicted=googleApps_test_pred50)
CrossTable(x = googleApps_test_labels, y = googleApps_test_pred50, prop.chisq = F)

table(Actual=googleApps_test_labels, Predicted=googleApps_test_pred96)
CrossTable(x = googleApps_test_labels, y = googleApps_test_pred96, prop.chisq = F)

```


Using Naive Bayes Approach
```{r}
cl_naivebayes <- naive_bayes(googleApps_train$`googleApps$rating` ~ ., data = googleApps_train )

y_pred <- predict(cl_naivebayes, newdata = googleApps_test) 
y_pred
```

```{r}
##Confusion Matrix
table(googleApps_test$`googleApps$rating`, y_pred) 
CrossTable(x = googleApps_test$`googleApps$rating`,y = y_pred, prop.chisq = F)
```

